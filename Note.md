# 体素光追的思路

已知与体素相关的有这样一些属性：pos、t、p、d、idx、scale

pos的范围是{0,1}，代表idx的二进制位，有三维，zyx，由低到高组成idx

p(t)=p+td    =》  ![1740474995952](image/Note/1740474995952.png)

t代表一个类似时间的系数值，表示一种先后顺序，p代表射线原点，d代表一个方向向量

idx是体素的索引，由三个二进制位组成，zyx顺序作为它的位

scale是体素的缩放级别

* advance：推进到兄弟体素
* push：进入子体素
* pop：进入到某个祖先体素同级的体素

## idx的分布：

![1740644840776](image/Note/1740644840776.png)

看不到到的那个角存放的索引是4

## 如何从一个体素到一个兄弟体素：

如图所示，这是一个xy轴的平面，光线投影到这个平面上时就得到了一条射线

![1740635555077](image/Note/1740635555077.png)

带入$(x_0,y_0)$到t的计算公式中，就能解出射线与两条平行于坐标轴的直线相交位置的时间t，比如上图中计算出的与x轴相交的tmin代表与x0的相交的时间，如果在射线反向延长线上计算出的t，那么它为负

与两条轴线相交得到的两对tmin和tmax对应区域的交集就是射线与矩形相交的部分，所以要取所有计算出的tmin中最大的非负数作为开始进入到矩形区域的时间，tmax中最小的非负数作为射出矩形区域的时间，从而确保光线在所有轴线上都进入到或者射出了矩形区域

对于一个大的体素，它包含八个子体素，它的位置信息由pos$ (t_{x1},t_{y1},t_{z1})$表示，这是它的中心的坐标

取0号索引的子体素棱角的位置为$(t_{x0},t_{y0},t_{z0})$，7号索引的棱角为 $(t_{x2},t_{y2},t_{z2})$

![1740627850023](image/Note/1740627850023.png)

要计算三维中的t值需要将光线与组成立方体的6个面求交，这通过将一对对角的坐标与光线求交实现，因为每个立方体的角都是三个面的交点，这两个角就能与六个面相交。可以将六个面划分为3对平行的面，每组对面都与某个轴线垂直，可以求出对应轴线的tmin与tmax，比如x轴垂直于yz面，那么这里求出的tmin与tmax就是x轴上求交得到的的时间，最后使用三个轴线最大的tmin和最小的tmax作为最终值，即光线进入立方体和离开立方体的时间

以上是对一个立方体，求得它的t的方法，在体素中需要对子体素进行求交，将tmax与三条轴线的tmax相比较，可以知道从哪条轴线垂直的面离开，比如tmax与x的tmax相等，那么光线就是延轴线x的方向从yz面离开的

## 如何得到下一个兄弟体素的idx：

知道了从哪个轴线垂直的面离开之后，就能够通过将对应轴线的idx的位翻转得到新的idx，idx的位顺序为zyx

![1740644840776](image/Note/1740644840776.png)

从图上可以看出，如果光线进入到1中，并从xz面离开1，那么翻转idx的y轴的值，旧idx的二进制位是001，翻转y轴得到011，也就是3是新的idx

## 如何判断是否离开父体素：

按照idx的计算方式，离开一个体素时，会计算一个新的idx'，在本算法中光线的方向在某个轴线上如果为正，那么idx该轴线的位只能增加，如果在离开一个体素时，idx的一个或多个位的翻转方向与光线方向相反，那么就说明将要离开父体素，应该执行pop操作，反之advance，继续探索同级体素

另外也可以让idx翻转方向与光线方向相反这一判断，变成idx不发生变化了就说明光线离开父体素，这可以通过下面的代码实现

```glsl
idx=mix(idx, sign(rd), step(tmax_xzy,vec3(tmax_final)));
```

由于idx对应的是光线移动中碰到的体素的索引，通过几何观察可以发现只有在光线到达体素中心的三个平面时，idx的位发生翻转才是有意义的，而光线最多只可能与三个面分别相交一次，所以将idx设计成对应位只会翻转一次，那么当idx不变时就说明离开父体素了，需要进行pop操作，上面的代码就能做到这一点

# 代码分析

## 存储体素到三维纹理

要存储体素到三维纹理texture3d需要使用到顶点着色器、几何着色器、片段着色器，几何着色器中的代码有一些关键的地方

```c
#version 450 core

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in vec3 pos[];
in vec3 normal[];
in vec2 tex_coord[];

out vec3 Pos;
out vec3 Normal;
out vec2 Tex_coord;

//将三角形投影到使其面积最大的、轴组成的平面上
void main(void){
	const vec3 p1 = pos[1] - pos[0];
	const vec3 p2 = pos[2] - pos[0];
	const vec3 p = abs(cross(p1, p2)); 
	for(int i = 0; i < 3; i++){
		Pos = pos[i];
		Normal = normal[i];
		Tex_coord = tex_coord[i];
//		gl_Position = vec4(Pos,1);
		if(p.z >= p.x && p.z >= p.y){
			gl_Position = vec4(Pos.x, Pos.y, 0, 1);
		} else if (p.x >= p.y && p.x >= p.z){
			gl_Position = vec4(Pos.y, Pos.z, 0, 1);
		} else {
			gl_Position = vec4(Pos.x, Pos.z, 0, 1);
		}
		EmitVertex();
	}
    EndPrimitive();
}



```

此代码将输入到几何着色器中的图元，也就是三角形，投影到三个主轴面组成的三角形中，面积最大的那一个，转换到了xy面上，这是标准化坐标空间NDC的投影到视口的面

![1741338302505](image/Note/1741338302505.png)

虽然三角形被转换到了xy面上，但这只是为了让片段着色器能处理到三角形最大的面积

三角形的顶点存储了一些属性，光栅化阶段需要从三角形顶点插值得到自己的属性。深度测试一般会在光栅化结束后，片段着色器开始前执行，由于深度测试会抛弃较深的片段，所以在执行这三个着色器时需要禁用深度测试，以保证片段不会被提前舍弃。由于禁用了深度测试，所有片段都会传入片段着色器中，尽管此时片段在xy平面，但它的属性中有一个原本片段的世界空间坐标信息，这是由它来自的三角形插值得到的，通过这个世界空间坐标，就相当于在转换前的轴面上向三角形填入体素，比喻一下，可以把xy平面的这个片段看作一个传送门，填入体素时，体素会传送到三角形片段所在的世界空间坐标下，具体操作是一些片段着色器的算法，现在不多做解释

下面是一个示意图，xy的三角形假设是有xz面的三角形得到，xy面三角形画圈的地方假设是一个片段，创建这个片段相关的体素，相当于从xz平面将该体素填入到三角形上

![1741339813624](image/Note/1741339813624.png)

为什么需要最大的三角形投影呢，这是为了避免体素产生较大空隙，从而出现漏光、体素缺失的问题，具体可以参考这篇文章

[[译]体素技术介绍_体素法是什么-CSDN博客](https://blog.csdn.net/jxw167/article/details/85247237)
